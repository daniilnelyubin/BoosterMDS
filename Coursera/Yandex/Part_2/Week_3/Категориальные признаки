Категориальные признаки и работа с ними

Категориальные переменные описывают дискретное пространство признаков например литературный жанр или размер одежды (l,xl,xxl и тд). Все категориальные признаки можно разделить на два типа: номинальные и порядковые. Если смотреть на пример выше, то жанр литературы будет номинальным признаком, а размер одежды порядковым. Главное отличие порядкового признака от номинального, в том, что мы их можем сравнивать. Например xxl больше чем l, а вот с жанром литературы так не получится (как сравнить драму и приключение!?)
Чаще всего категориальные признаки представляются в качестве строковых объектов, поэтому приходится их представлять в виде чисел. Рассмотрим пример c простейшим кодировщиком LabelEncoder:

arr = ["Drama","Epic","Lyric","Comedy","Drama"]
label_encoder = LabelEncoder()
label_encoder.fit_transform(arr)

> array([1, 2, 3, 0, 1])

LabelEncoder присваивает каждому объекту номер и дальше мы можем работать с объектами, как с цифрами.

Модели построенные с закодированными через LabelEncoder данными бывает трудно интерпретировать. Для лучшей интерпретации и более простого обучения можно выбрать OneHotEncoder или DummyEncoder (DummyEncoder будет немного получше, так как для кодирования данных используется k-1 классов вместо k)
Рассмотрим пример с кодировщиком OneHotEncoder:

arr = pd.DataFrame({"Genre":["Drama","Epic","Lyric","Comedy","Drama"]})
label_encoder = OneHotEncoder()
arr_one = label_encoder.fit_transform(arr)
arr_one.toarray()

Исходную матрицу:

	Genre

0	Drama
1	Epic
2	Lyric
3	Comedy
4	Drama

Кодировщик закодировал,как:

>array([[0., 1., 0., 0.],
>       [0., 0., 1., 0.],
>       [0., 0., 0., 1.],
>       [1., 0., 0., 0.],
>       [0., 1., 0., 0.]])

Тоесть данный кодировщик создает новую колонку для каждого класса в данной категории и при его наличии у объекта ставит 1 в данную колонку.
Если закодировать таким образом данные, то после обучения линейной регрессии будет проще интерпретироват веса.
